{"name":"Try","tagline":"Implementation of the Try-Success-Failure Scala API for Java 8","body":"# Scala's Try-Success-Failure for Java 8 #\r\n\r\nThis API is a Java 8 implementation of the <a href=\"http://www.scala-lang.org/api/current/#scala.util.Try\">Scala Try API</a>,\r\noriginally implemented by <a href=\"https://twitter.com/\">Twitter</a> Engineers and later added to the Scala Standard Library.\r\n\r\nThe `Try` type represents a computation that may fail. If the computation is successful it returns\r\nthe value wrapped in a `Try.Success` otherwise the `java.lang.Exception` wrapped in a `Try.Failure`.\r\n\r\nIn order to use `Try` you need to call the `Try.apply(FailableSupplier)` method providing a lambda with\r\nthe same signature used for a common `java.util.function.Supplier`.\r\nIndeed `FailableSupplier` is just a `java.util.function.Supplier` with a\r\n`throws Exception` added to its `get` method.\r\n\r\nNote that I'm not saying here that the `try-catch` approach must be abandoned in favour of `Try-Success-Failure`.\r\nIndeed there are cases where you would use the traditional `try-catch` pattern but, in general, I think this API provides\r\na more *fluent interface* to deal with exceptions.\r\n\r\n## Build ##\r\nThis project is managed with [Maven](http://maven.apache.org/) so it can be built using:\r\n\r\n```\r\n$ git clone https://github.com/typesafely/try.git\r\n$ cd try\r\n$ mvn package\r\n```\r\n\r\nYou'll find the `jar` under the usual `target` directory.\r\n\r\n## Running the examples in source code ##\r\nUsing [Maven](http://maven.apache.org/) and the [exec-maven-plugin](http://mojo.codehaus.org/exec-maven-plugin/) \r\nyou can run the main classes representing the examples for this project. For instance, to run the `ReadFileLines` main\r\nclass you can use:\r\n\r\n```\r\n$ mvn exec:java -Dexec.mainClass=\"org.typesafely.example.ReadFileLines\"\r\n```\r\n\r\nThe changing part is the full path to the main class you intend to run.\r\n\r\n## Examples ##\r\nIn order to get you acquainted with this API each example will be provided using both the same old `try-catch` pattern\r\nand the new `Try` API.\r\n\r\n### Example 1: Read a file line by line ###\r\nAs a first example consider the code you need to implement a method to read a file line by line in Java 8. \r\n#### Using the traditional try-catch block ####\r\n```java\r\npublic static List<String> readFile(String file) {\r\n\r\n    List<String> lines;\r\n    try {\r\n        lines = Files.readAllLines(new File(file).toPath());\r\n    } catch (IOException e) {\r\n        lines = Arrays.asList(\"Could not read the file: \" + file);\r\n    }\r\n\r\n    return lines;\r\n}\r\n```\r\n\r\n`readFile` reads the content of a file, line by line, into a `List<String>`. In case of exception the method\r\nreturns a `List<String>` with just one line: *\"Could not read...\"*. \r\n#### Using the Try API ####\r\n```java\r\npublic static List<String> readFile(String file) {\r\n\r\n    return Try.apply(() -> Files.readAllLines(new File(file).toPath()))\r\n            .getOrElse(Arrays.asList(\"Could not read the file: \" + file));\r\n\r\n}\r\n```\r\n\r\nIn this case a lambda is passed to `Try.apply`. The `Try`'s \r\n`getOrElse` method returns the value obtained by the call to `Files.readAllLines(new File(file).toPath())` if \r\nno exception is thrown or whatever you passed to it in case of exception. Of course everything is *type safe*, \r\nin the sense that `getOrElse` will accept only arguments whose type is the same of `Try`'s. Thanks to the\r\ntype inferer there's no need to specify the type for `Try` in the previous code. In fact, it is equivalent to\r\n`Try.<List<String>>apply(() -> Files.readAllLines(new File(file).toPath()))` where you explicitly say that\r\nthe `Try`'s type is `List<String>`.\r\n\r\nWhich version do you like more? The `try-catch` approach or the `Try` one? \r\nIt may be a matter of taste or just because I'm used to it but I prefer the latter--also\r\nbecause otherwise I wouldn't have written this API! :-)\r\n\r\n### Example 2: Read the content of a URL into a String ###\r\n#### Using the traditional try-catch-finally block ####\r\n```java\r\npublic static String urlToString(String url, String errorMessage) {\r\n    Scanner scanner = null;\r\n    try {\r\n        scanner = new Scanner(new URL(url).openStream(), \"UTF-8\");\r\n        String result = scanner.useDelimiter(\"\\\\A\").next();\r\n        scanner.close();\r\n        return result;\r\n    } catch (IOException e) {\r\n        return errorMessage;\r\n    } finally {\r\n        if (scanner != null) {\r\n            scanner.close();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`urlToString` reads the content of a URL into a `String`. The method takes two parameters: `url` which is the \r\n`String` representing the URL and `errorMessage` which is the `String` to return if the URL content retrieving fails. \r\nNotice the boilerplate code. You need to initialize the `scanner` reference\r\nto `null`. You also have to use a finally block and close the `Scanner` object after checking if it is not `null`.\r\nWouldn't it be great if you could avoid such a boilerplate code and let an API do it for you? Well, take a look\r\nat the, semantically, same code in the following example.\r\n\r\n#### Using the Try API ####\r\n```java\r\npublic static String urlToString(String url, String errorMessage) {\r\n    Try<Scanner> scanner = Try.apply(() -> new Scanner(new URL(url).openStream(), \"UTF-8\"));\r\n    String result = scanner.map(s -> s.useDelimiter(\"\\\\A\").next()).getOrElse(errorMessage);\r\n    scanner.forEach(s -> s.close());\r\n    return result;\r\n}\r\n```\r\n\r\nLook ma, no `null` initialization, no `try-catch-finally` block and no `null` check before closing `scanner`!\r\nThe first line of the method creates a `Try<Scanner>` object which can be, as usual, a `Success<Scanner>` or a \r\n`Failure<Scanner>` depending on the result of the lambda. The `map` method is then used to transform it \r\ninto a `Try<String>`, taking care of the fact that if the result\r\nof `Try.apply` is a `Failure<Scanner>` now it just becomes a `Failure<String>` otherwise it gets mapped into a \r\n`Success<String>`. `getOrElse` then extracts its content (a `String`) if it's a `Success` or returns `errorMessage` if\r\nit's a `Failure`. Afterward the `forEach` method takes care of closing the `Scanner` object if it is of type\r\n`Success<Scanner>` otherwise it does nothing. Finally the result is returned. \r\n\r\nTypically you use `map` to transform something into something else, \r\nwhile you employ `forEach` to *consume* something, that is to use it someway. As a matter of fact \r\n`forEach` has a `void` return type.\r\n\r\nThe `Try` version is declarative whilst the `try-catch-finally` one is imperative. Expressing the `Try` version in \r\nwords you have: \"*Try* to create a `Scanner` object for the given URL. Afterward *map* this object into a `String` *or else*\r\nuse this other `String` if it's a failure. In the end close the `Scanner` object.\" \r\n\r\n### Example 3: Integer division ###\r\nThis is an interesting one because it shows another peculiarity of the `Try` API. You may already know that Java\r\nhas both checked and unchecked exceptions. For checked exceptions the compiler won't accept your code\r\nif you forget to handle them. However unchecked exceptions such as `NullPointerException`, `IllegalArgumentException`,\r\n`RuntimeException` and so on are not notified by the compiler if you don't handle them. Consider the following code\r\nsnippet:\r\n```java\r\nSystem.out.println(\"Enter the dividend press Return and then enter the divisor: \");\r\nScanner dividend = new Scanner(System.in);\r\nScanner divisor = new Scanner(System.in);\r\n\r\nint num = dividend.nextInt();\r\nint denum = divisor.nextInt();\r\nString res = \"The result of division is: \" + (num / denum);\r\nSystem.out.println(res);\r\n```\r\n\r\nThe previous code asks the user to enter two integers and then performs their division. The problem is that it could\r\nthrow two types of unchecked exceptions and the compiler of course wouldn't tell you. You are required to know it \r\nyourself. The two unchecked exceptions I'm talking about are `java.util.InputMismatchException` and \r\n`java.lang.ArithmeticException` if the user enter a non-integer or zero as the divisor, respectively. Now,\r\nif you have a decent mathematical background you know you can't divide by zero. Furthermore you can also imagine that\r\n`Scanner`'s `nextInt` method may throw some type of exception if you enter a non-integer. However, in both cases\r\nyou have to look up the type of exception. Yes, you can use a generic `catch(Exception e)` and capture them all if you're\r\nnot interested in the specific type or you could avoid using `try-catch` in the first place thanks to `Try`. Here are both \r\nimplementations.\r\n#### Using the traditional try-catch block ####\r\n```java\r\npublic static void divideWithoutTry() {\r\n\r\n    System.out.println(\"Enter the dividend press Return and then enter the divisor: \");\r\n    Scanner dividend = new Scanner(System.in);\r\n    Scanner divisor = new Scanner(System.in);\r\n\r\n    String res;\r\n    try {\r\n        res = \"The result of division is: \" + (dividend.nextInt() / divisor.nextInt());\r\n    } catch(InputMismatchException|ArithmeticException e) {\r\n        res = \"The integers you entered are not valid or the divisor is zero.\";\r\n    }\r\n\r\n    System.out.println(res);\r\n}\r\n```\r\n\r\n#### Using the Try API ####\r\n```java\r\npublic static void divideWithTry() {\r\n\r\n    System.out.println(\"Enter the dividend press Return and then enter the divisor: \");\r\n    Scanner dividend = new Scanner(System.in);\r\n    Scanner divisor = new Scanner(System.in);\r\n\r\n    String res = Try.apply(() -> dividend.nextInt() / divisor.nextInt())\r\n            .map(quotient -> \"The result of division is: \" + quotient)\r\n            .getOrElse(\"The integers you entered are not valid or the divisor is zero.\");\r\n\r\n    System.out.println(res);\r\n}\r\n```\r\n\r\nIn the previous code `map` maps the `Integer` result into a `String`. After the `map` call you have something\r\nthat was a `Try<Integer>` transformed into a `Try<String>`. This is another important aspect of `Try`. Its type can be\r\nmapped into another type without the need to do explicit exception-handling in all of the places that an \r\nexception might occur. I mean if `dividend.nextInt() / divisor.nextInt()` caused an exception the result of `Try.apply`\r\nwould be a `Try.Failure` instance. Nevertheless it's type would be `Try<String>`. This lets you call `getOrElse`\r\npassing a `String` to it.\r\n\r\n\r\n\r\n### Integer sum ###\r\nAn important property of `Try` is its ability\r\nto *pipeline* (*chain* if you prefer)  operations, catching exceptions along the way thanks to its `flatMap` method.\r\nIf you are not a functional programmer concepts such as `flatMap/map` might not be easy to grasp\r\nat first. However you'll get used to them when you become one and, in the end, you'll love them. \r\nMoreover you're going to encounter\r\nthese methods more and more often since some important Java 8 classes already implement them\r\n(e.g. `java.util.Optional` and `java.util.stream.Stream`). Anyway for the moment just take for\r\ngranted that to pipeline more than two operations, say N, you just need to chain them by using N - 1\r\n`flatMap` calls and a last call to `map`. For example, suppose you have 3 variables--x, y and z--being\r\nof type `Try<Integer>` and you just want to sum them up. Here is the code you need:\r\n\r\n```java\r\nx.flatMap(a -> y.flatMap(b -> z.map(c -> a + b + c)))\r\n```\r\n\r\nApart from the methods seen in these examples, such as `map`, `flatMap` and `getOrElse`, `Try` \r\nhas many other useful methods. See the `TryTest` class for a thorough coverage of all its methods.\r\n\r\n## Javadoc ##\r\n<a href=\"http://typesafely.github.io/try/apidocs/\">API documentation</a> for this project.\r\n\r\n## Bugs and Feedback ##\r\nFor bugs, questions and discussions please use the [Github Issues](https://github.com/typesafely/try/issues).\r\n\r\n## Conclusion ##\r\nWhat else to say? Give Try a try (pun intended :-)) you won't regret once you get used to it.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}