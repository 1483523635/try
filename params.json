{"name":"Try","tagline":"Implementation of the Try-Success-Failure Scala API for Java 8","body":"# Scala's Try-Success-Failure for Java 8 #\r\n\r\nThis API is a Java 8 implementation of <a href=\"http://www.scala-lang.org/api/current/#scala.util.Try\">Scala Try API</a>,\r\noriginally implemented by the guys at <a href=\"https://twitter.com/\">Twitter</a> and later added to the Scala Standard Library.\r\n\r\nThe `Try` type represents a computation that may fail. If the computation is successful returns\r\nthe value wrapped in a `Try.Success` otherwise returns the\r\n`java.lang.Exception` wrapped in a `Try.Failure`.\r\n\r\nTo use `Try` you need to call the `Try.apply(FailableSupplier)` method passing in a lambda with\r\nthe same signature used for a common `java.util.function.Supplier`.\r\nIndeed `FailableSupplier` is just a `java.util.function.Supplier` with a\r\n`throws Exception` added to its `get` method.\r\n\r\n## Examples ##\r\n### Read a file line by line ###\r\nAs a first example consider the code you need to implement a method to read a file line by line in Java 8. \r\nUsing the traditional `try-catch` block you would implement it as follows:\r\n\r\n```java\r\npublic static List<String> readFile(String file) {\r\n\r\n    List<String> lines;\r\n    try {\r\n        lines = Files.readAllLines(new File(file).toPath());\r\n    } catch (IOException e) {\r\n        lines = Arrays.asList(\"Could not read the file: \" + file);\r\n    }\r\n\r\n    return lines;\r\n}\r\n```\r\n\r\n`readFile` reads the content of a file, line by line, into a `List<String>`. In case of exception the method\r\nreturns a `List<String>` with just one line: *\"Could not read...\"*. \r\n\r\nHowever, using the `Try` API the previous method becomes:\r\n\r\n```java\r\npublic static List<String> readFile(String file) {\r\n\r\n    return Try.apply(() -> Files.readAllLines(new File(file).toPath()))\r\n            .getOrElse(Arrays.asList(\"Could not read the file: \" + file));\r\n\r\n}\r\n```\r\n\r\nWhich version do you like more? :-)\r\n\r\n### Integer division ###\r\nAs another example, `Try` can be used to perform division on a user-defined input, without the need to do explicit\r\nexception-handling in all of the places that an exception might occur:\r\n\r\n```java\r\nSystem.out.println(\"Integer division\");\r\nSystem.out.println(\"Enter the dividend press Return and then enter the divisor: \");\r\nScanner dividend = new Scanner(System.in);\r\nScanner divisor = new Scanner(System.in);\r\n\r\nTry<Integer> num = Try.apply(dividend::nextInt);\r\nTry<Integer> denom = Try.apply(divisor::nextInt);\r\n\r\nTry<Integer> result = num.flatMap(x -> denom.map(y -> x / y));\r\nTry<String> resultTryStr = result.map(i -> \"The result of division is: \" + i);\r\nString resultStr = resultTryStr.getOrElse(\"The integers you entered are not valid or the divisor is zero.\");\r\nSystem.out.println(resultStr);\r\n```\r\nIn this case if you enter two valid integers with the second one--the divisor--being different from zero\r\nthen the code prints out `The result of division is: $RESULT`, where `$RESULT` is the division between the first\r\nand the second number. On the other hand, if you either enter non valid integers--such as a string--or the second\r\nnumber is zero then you'll get the message `The integers you entered are not valid or the divisor is zero.`\r\nprinted out.\r\n\r\nAn important property of `Try` shown in the previous code snippet is its ability\r\nto *pipeline* (*chain* if you prefer)  operations, catching exceptions along the way thanks to its `flatMap` method.\r\nIf you are not a seasoned functional programming geek concepts such as `flatMap/map` might not be easy to grasp\r\nat first. However you'll get used to them and, in the end, you'll love them. Moreover you're going to encounter\r\nthese methods more and more often since some important Java 8 classes already implement them\r\n(e.g. `java.util.Optional` and `java.util.stream.Stream`. Anyway for the moment just take for\r\ngranted that to pipeline more than two operations, say N, you just need to chain them by using N - 1\r\n`flatMap` calls and a last call to `map` (see the **Integer sum** example).\r\n\r\n### Integer sum ###\r\nSuppose you have 3 variables (x, y and z) being\r\nof type `Try<Integer>` and you just want to sum them up. The code you need for doing that is the\r\nfollowing:\r\n\r\n```java\r\nx.flatMap(a -> y.flatMap(b -> z.map(c -> a + b + c)))\r\n```\r\n\r\nApart from the methods seen in these examples, such as `map`, `flatMap` and `getOrElse`, `Try` has many other useful methods. See the `TryTest`\r\nclass for a thorough coverage of all methods.\r\n\r\n## Javadoc ##\r\n<a href=\"http://typesafely.github.io/try/apidocs/\">API documentation</a> for this project.\r\n\r\n## Build ##\r\n\r\nTo build:\r\n\r\n```\r\n$ git clone https://github.com/typesafely/try.git\r\n$ cd try\r\n$ mvn package\r\n```\r\n\r\nYou'll find the `jar` under the usual `target` directory.\r\n\r\n## Bugs and Feedback ##\r\n\r\nFor bugs, questions and discussions please use the [Github Issues](https://github.com/typesafely/try/issues).\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}